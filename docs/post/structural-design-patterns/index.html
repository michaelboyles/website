<!doctype html><html lang=en><head>
<title>Design patterns reviewed - part 2: structural | Michael Boyles</title>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,minimum-scale=1,initial-scale=1">
<meta name=description content="A review of the structural design patterns used in software development">
<meta name=generator content="Hugo 0.88.1">
<link rel=stylesheet href=https://boyl.es/css/style.css integrity crossorigin=anonymous type=text/css>
<link rel=stylesheet href=https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css integrity=sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN crossorigin=anonymous type=text/css>
<link href="https://fonts.googleapis.com/css2?family=Noto+Serif:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel=stylesheet>
<script>__FLAMEWARS_CONFIG={awsUrl:'https://rgry1shcqe.execute-api.eu-west-2.amazonaws.com/default',googleClientId:'164705233134-ahoqn1p8em908f190tjgluh2fq6alqo5.apps.googleusercontent.com'}</script>
<script defer language=javascript type=text/javascript src=https://boyl.es/js/flamewars.js integrity></script>
</head><body>
<div class=header><nav>
<ul class=nav>
<li><a href=/ title>Home</a></li>
<li><a href=/about/ title>About</a></li>
</ul>
</nav>
<ul class=social-icons>
<li>
<a href=https://github.com/michaelboyles rel=me title=GitHub aria-label=GitHub>
<i class="fa fa-github" aria-hidden=true></i>
</a>
</li>
<li>
<a href=https://stackoverflow.com/users/1898563/michael rel=me title=StackOverflow aria-label=StackOverflow>
<i class="fa fa-stack-overflow" aria-hidden=true></i>
</a>
</li>
<li>
<a href=https://www.linkedin.com/in/boylesm/ rel=me title=Linkedin aria-label=Linkedin>
<i class="fa fa-linkedin" aria-hidden=true></i>
</a>
</li>
<li>
<a href=mailto:michael@boyl.es rel=me title=Email aria-label=Email>
<i class="fa fa-envelope" aria-hidden=true></i>
</a>
</li>
<li>
<a href="https://latexonline.cc/compile?git=https%3A%2F%2Fgithub.com%2Fmichaelboyles%2Fwebsite&target=static%2Fdocs%2Fcv.tex&command=xelatex&trackId=1598651052286" rel=me title=CV aria-label=CV>
<i class="fa fa-file" aria-hidden=true></i>
</a>
</li>
</ul>
</div>
<div class=main>
<div class=post>
<h1 class=title>Design patterns reviewed - part 2: structural</h1>
<div class=meta>
<span class=date>25 October 2020</span>
<ul class=tags>
<li class=tag><a href=/tags/design/ title="View more posts about design">design</a></li></ul>
<a href=#comments class=num-comments>Comments</a>
</div>
<div class=content><p>This is the second post in a series in which I’m reviewing
<a href=https://en.wikipedia.org/wiki/Software_design_pattern>software design patterns</a>. This time out I&rsquo;m taking a look at
<a href=https://en.wikipedia.org/wiki/Structural_pattern>structural patterns</a>. These are all strategies for defining and
managing relationships between classes and interfaces.</p>
<p>In alphabetical order, they are:</p>
<h2 id=adapterhttpsenwikipediaorgwikiadapter_pattern><a href=https://en.wikipedia.org/wiki/Adapter_pattern>Adapter</a></h2>
<p>The adapter pattern is a good pattern with modest utility. It’s a useful way to reuse third party code. That said, if
you find yourself writing adapters between your own interfaces often then something’s probably wrong with your
abstractions.</p>
<h2 id=bridgehttpsenwikipediaorgwikibridge_pattern><a href=https://en.wikipedia.org/wiki/Bridge_pattern>Bridge</a></h2>
<p>The bridge pattern is inherently bad because it relies on inheritance to achieve its objective. What GoF call the
“abstraction” must contain a reference to an “implementor”, meaning it must be an abstract class rather than an
interface. I don’t see why the so-called “refined abstractions” cannot hold this reference themselves.</p>
<p><img src=/images/posts/structural-design-patterns/bridge-pattern-uml.png alt="Bridge pattern UML">
<em>Bridge pattern UML</em></p>
<p>By using inheritance you save perhaps 3 lines per class, but you lose the flexibility of a <em>Refined Abstraction</em>
deciding that it actually doesn’t require an <em>Implementor</em> instance. Here’s what I’d do instead:</p>
<p><img src=/images/posts/structural-design-patterns/revised-bridge-pattern-uml.png alt="Revised bridge pattern UML">
<em>Revised bridge pattern UML</em></p>
<p>The existence of <em>Abstraction</em> now is largely immaterial. I only kept it to demonstrate the difference more clearly.</p>
<p>I don’t think this is even sophisticated enough to be worthy of the designation “pattern” anymore; it’s just
composition and delegation. Apparently <a href=https://en.wikipedia.org/wiki/Delegation_pattern>someone out there disagrees with me</a>.</p>
<h2 id=compositehttpsenwikipediaorgwikicomposite_pattern><a href=https://en.wikipedia.org/wiki/Composite_pattern>Composite</a></h2>
<p>This is a good one for plenty of tree-like structures. Something like a scene graph seems like good use-case. I don&rsquo;t
find too much use for it in practice but it seems perfectly fine.</p>
<h2 id=decoratorhttpsenwikipediaorgwikidecorator_pattern><a href=https://en.wikipedia.org/wiki/Decorator_pattern>Decorator</a></h2>
<p>This is easily my favourite design pattern. The decorator pattern allows you to keep classes small and implement
behaviour in a composable way. Take this example:</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#00a>final</span> Request request = <span style=color:#00a>new</span> CachingRequest(
    <span style=color:#00a>new</span> ResponseValidatingRequest(
         <span style=color:#00a>new</span> HttpRequest(<span style=color:#a50>&#34;https://www.google.com&#34;</span>)
    )
);
String body = request.<span style=color:#1e90ff>getResponseBody</span>();
</code></pre></div><p>Rather than having a single class responsible for making an HTTP request, validating the response and caching the
result, the functionality can be split out into one implementation and two further decorators.</p>
<p>The decorators are easy to test because they’re unaware of the underlying transport. If the behaviour needs to change,
say to remove the caching, then it’s just a matter of changing the composition at the point of instantiation.</p>
<h2 id=facadehttpsenwikipediaorgwikifacade_pattern><a href=https://en.wikipedia.org/wiki/Facade_pattern>Facade</a></h2>
<p>The goal of this pattern is to “<em>minimize the communication and dependencies between subsystems</em>”, but why do these
subsystems exist in the first place? Perhaps several microservices would provide a better delineation between the
distinct components.</p>
<p>It seems to solve a similar problem to dependency injection in a less convenient way. That said, I can see some
situations where it might come in handy; when refactoring a monolith, employing the facade pattern might be a good
first step.</p>
<h2 id=flyweighthttpsenwikipediaorgwikiflyweight_pattern><a href=https://en.wikipedia.org/wiki/Flyweight_pattern>Flyweight</a></h2>
<p>As I see it, this is just a specific form of the object pool pattern. The only distinction is the separation of
intrinsic and extrinsic state in order to make objects poolable. It’s just a performance optimization, a workaround for
a lack of support for <a href=https://openjdk.java.net/jeps/169>value objects</a>. Avoid it if possible.</p>
<h2 id=marker-interfacehttpsenwikipediaorgwikimarker_interface_pattern><a href=https://en.wikipedia.org/wiki/Marker_interface_pattern>Marker interface</a></h2>
<p>This isn’t a GoF pattern but I thought it was prevalent enough to include anyway. The purist in me wants to scream that
this is a huge anti-pattern but the reality is more nuanced than that.</p>
<p>Markers should not be used as a limited form of reflection. Where I have found them useful is to provide additional
compile-time checks for methods which would otherwise only fail at runtime.</p>
<p>Consider the following example, using Jackson to serialize an instance to a JSON string.</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#00a>public</span> String <span style=color:#0a0>getJson</span>(Object obj) {
    <span style=color:#00a>return</span> <span style=color:#00a>new</span> ObjectMapper().<span style=color:#1e90ff>writeValueAsString</span>(obj);
}
</code></pre></div><p>The <code>writeValueAsString</code> method accepts any Object, so if I want my <code>getJson</code> method to serialize several unrelated
types of messages, I have to declare my parameter as accepting Object too.</p>
<p>The problem here is that <code>getJson</code> can be called with an <code>Exception</code>, a <code>BigDecimal</code>, or a <code>DateTimeFormatterBuilder</code>.
These are clearly mistakes.</p>
<p>If all my messages implement a <code>JsonMessage</code> marker interface, I can change the parameter so that only “whitelisted”
implementations are allowed, preventing possible mistakes.</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#00a>public</span> String <span style=color:#0a0>getJson</span>(JsonMessage message) {           <span style=color:#aaa;font-style:italic>// marker interface
</span><span style=color:#aaa;font-style:italic></span>    <span style=color:#00a>return</span> <span style=color:#00a>new</span> ObjectMapper().<span style=color:#1e90ff>writeValueAsString</span>(obj); <span style=color:#aaa;font-style:italic>// accepts Object
</span><span style=color:#aaa;font-style:italic></span>}
</code></pre></div><p>Arguably, this use of marker interfaces is just a workaround for poorly designed interfaces.</p>
<h2 id=proxyhttpsenwikipediaorgwikiproxy_pattern><a href=https://en.wikipedia.org/wiki/Proxy_pattern>Proxy</a></h2>
<p>This is a good one for the same reasons that the decorator pattern is. In fact, a proxy implementation is likely to look
quite similar to a decorator. The book addresses this and suggests that one major difference is in the intent behind the
application of the pattern.</p>
<p>I don’t really agree that a different intent means it is deserving of a distinct pattern, especially given that they
present multiple variations on a single pattern several times elsewhere. But I can sympathise with the struggle of an
author to meet their word count - what do you think I&rsquo;m doing right now? They managed to get an extra 15 pages of
material out of the same idea and all I managed was one lousy paragraph.</p>
<hr>
<p><a href=/post/creational-design-patterns/>Part 1 - Creational Design Patterns</a></p>
<p>Part 3 will be on Behavioural Design Patterns</p></div>
<hr>
<div id=comments></div>
</div>
</div>
</body>
</html>