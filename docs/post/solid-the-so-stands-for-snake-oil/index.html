<!doctype html><html lang=en><head><title>SOLID: the 'SO' stands for Snake Oil | Michael Boyles</title><meta charset=utf-8><meta name=viewport content="width=device-width,minimum-scale=1,initial-scale=1"><meta name=generator content="Hugo 0.74.3"><link rel=stylesheet href=https://boyl.es/css/style.css integrity crossorigin=anonymous type=text/css><link rel=stylesheet href=https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css integrity=sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN crossorigin=anonymous type=text/css><link href="https://fonts.googleapis.com/css2?family=Noto+Serif:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel=stylesheet></head><body><div class=header><nav><ul class=nav><li><a href=/>Home</a></li><li><a href=/about/>About</a></li></ul></nav><ul class=social-icons><li><a href=https://github.com/michaelboyles rel=me title=GitHub aria-label=GitHub><i class="fa fa-github" aria-hidden=true></i></a></li><li><a href=https://stackoverflow.com/users/1898563/michael rel=me title=StackOverflow aria-label=StackOverflow><i class="fa fa-stack-overflow" aria-hidden=true></i></a></li><li><a href=https://www.linkedin.com/in/boylesm/ rel=me title=Linkedin aria-label=Linkedin><i class="fa fa-linkedin" aria-hidden=true></i></a></li><li><a href=mailto:michael@boyl.es rel=me title=Email aria-label=Email><i class="fa fa-envelope" aria-hidden=true></i></a></li><li><a href="https://latexonline.cc/compile?git=https%3A%2F%2Fgithub.com%2Fmichaelboyles%2Fwebsite&target=static%2Fdocs%2Fcv.tex&command=xelatex&trackId=1598651052286" rel=me title=CV aria-label=CV><i class="fa fa-file" aria-hidden=true></i></a></li></ul></div><div class=main><div class=post><h1 class=title>SOLID: the 'SO' stands for Snake Oil</h1><div class=meta><span class=date>13 September 2020</span>
<span class=reading-time></span><ul class=tags><li class=tag><a href=/tags/design/ title="View more posts about design">design</a></li></ul></div><div class=content><p>SOLID is possibly the most over-hyped concept in all of software engineering. You can throw away that jar of Sudocrem because we&rsquo;ll have no fence-sitting today, no sir.</p><p>I often hear SOLID touted as some profound programming philosophy with the power to absolve us from all of our software sins. Like a Buddhist achieving enlightenment, it is a doctrine that requires deep and profound meditation but, once internalized, you will unlock <a href=https://stackoverflow.com/users/22656/jon-skeet>a truly limitless potential</a>.</p><p>It may be comforting to convince yourself that that&rsquo;s true but it&rsquo;s not. I think that software engineers sometimes feel like imposters within engineering. Civil engineers don’t build bridges knowing there are cracks in the foundations that they can just patch after it’s open (“don’t worry, guys, we’ve got a Jira for that”). Well, <a href=https://en.wikipedia.org/wiki/List_of_bridge_failures>maybe they do</a> but the point is that these insecurities bring along with them a desire to identify some fundamental principles of our discipline, so that we can tell ourselves that we&rsquo;re definitely not just <a href=https://en.wikipedia.org/wiki/Infinite_monkey_theorem>monkey&rsquo;s sitting at typewriters</a>. No, we’re applying established axioms of design.</p><p>I believe that SOLID completely fails in its attempt to help us to design and write better software; it’s perfectly possible to follow all of the principles to the letter and still produce some absolute garbage. They’re simultaneously banal enough that any experienced developer should already be following them, and obtuse enough to confuse and disorient a beginner. Saying something in a convoluted way does not make the underlying idea deep or complex.</p><p>Let&rsquo;s break them down one by one and see what we’re dealing with.</p><h2 id=single-responsibility-principlehttpsenwikipediaorgwikisingle-responsibility_principle><a href=https://en.wikipedia.org/wiki/Single-responsibility_principle>Single-Responsibility Principle</a></h2><p>This principle states a class should have one responsibility or &ldquo;<em>only one reason to change</em>&rdquo;. The natural follow-up question is “what constitutes a &lsquo;responsibility&rsquo;?” It’s often <a href=https://softwareengineering.stackexchange.com/questions/345018/when-using-the-single-responsibility-principle-what-constitutes-a-responsibili>debatable</a>.</p><p>The underlying idea here is sound but it&rsquo;s hardly earth-shattering. I’d word it another way: keep your classes as small as possible. Smaller classes are easier to understand, are more maintainable, and are easier to test. My advice is more direct but of course it has the problem: when <em>precisely</em> should you start to break out the functionality of one class into multiple classes? We’ve all been unlucky enough to see a few monstrous 2000-line “classes” which have clearly crossed that line but there’s a fair bit of grey area too. You’ll get a better sense of where that line sits through experience, not by reading this mumbo-jumbo.</p><h2 id=open-closed-principlehttpsenwikipediaorgwikiopene28093closed_principle><a href=https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle>Open-Closed Principle</a></h2><p>This is by far the most offensively awful tenet of SOLID, and often cited as being <a href=https://www.dictionary.com/browse/wrong>&ldquo;the most important&rdquo;</a> by Uncle Bob<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>. It states &ldquo;<em>software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification</em>&rdquo;. What this advocates is that you should extend a class and perform your bug fix or change in behaviour by way of overriding its methods, rather than by altering it existing implementation.</p><p>Inheritance is usually awful. It’s very often the wrong approach and should be used very sparingly. Classes with complex inheritance hierarchies are hard to understand and hard to test exhaustively. You should not be looking for reasons to use it proactively.</p><p>This principle was <a href=https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle#Polymorphic_open%E2%80%93closed_principle>redefined to apply to interfaces</a>. Effectively it states that your interfaces should not change, but that you may add new implementations.</p><p>If anything speaks to SOLID’s lack of coherency, it’s that they had to retroactively completely redefine one of the definitions.</p><p>Both variants of this principle are extremely averse to change, which I don&rsquo;t understand. Making breaking changes for clients should not be done lightly but sometimes we have to do that for the good of the overall system design. As long as those changes are properly communicated (<a href=https://semver.org/>semver</a>, a migration guide, etc.), with adequate time to transition then it shouldn&rsquo;t be a huge problem. Software development is often an iterative process. We learn more about the optimal design as we build the system; that&rsquo;s what makes Agile such a popular methodology. This principle seems to directly contradict that idea.</p><p>We should build systems which are flexible to change by striving to choose the right abstractions and loosely coupling components, but if we later learn that we choose the wrong abstractions, that shouldn’t be a lifelong burden that we need to live with.</p><h2 id=liskov-substitution-principlehttpsenwikipediaorgwikiliskov_substitution_principle><a href=https://en.wikipedia.org/wiki/Liskov_substitution_principle>Liskov Substitution Principle</a></h2><p>In essence, what this principle states is that if a method is declared as accepting a Collection and it’s passed an ArrayList then it should work as expected (explained below if you’re not Java-savvy).</p><p>When implementing or extending a type then you should be careful not to break the contracts they’ve defined. Of course that’s true but that’s a fundamental aspect of subtyping. Maybe this was a revolutionary idea in the 1980s but are there still people who are oblivious to this, excluding complete beginners? If something this basic made the list then why didn’t any number of other basic core ideas like encapsulation?</p><h2 id=interface-segregation-principlehttpsenwikipediaorgwikiinterface_segregation_principle><a href=https://en.wikipedia.org/wiki/Interface_segregation_principle>Interface segregation principle</a></h2><p>This principle kind of encompasses two things. The first is to design your interfaces so that they are small and specialized (&ldquo;segregation&rdquo;). Java&rsquo;s collections framework does this quite well. For example this hierarchy, from most generic to most specific:</p><ul><li>Iterable: something you can iterate over</li><li>Collection: something you can add and remove elements from</li><li>List: a sequence supporting random access</li><li>ArrayList: an array-based implementation</li></ul><p>I agree with this but designing interfaces - choosing the right abstractions - is hard. It’s something you can only learn from experience. You can only learn <em>how</em> to follow this principle by trial and error. I doubt that anyone had been deluding themselves into thinking that their interface with 100 methods was a stroke of genius until this came along.</p><p>This principle goes on to advocate that you give precedence to the most-general abstraction: &ldquo;<em>no client should be forced to depend on methods it does not use</em>&rdquo;, which is of course aided by having specialized interfaces. Nothing wrong with that.</p><h2 id=dependency-inversion-principlehttpsenwikipediaorgwikidependency_inversion_principle><a href=https://en.wikipedia.org/wiki/Dependency_inversion_principle>Dependency Inversion Principle</a></h2><p>This principle states &ldquo;<em>abstractions should not depend on details</em>&rdquo;. Effectively what this says is that if your method only requires the methods of Collection, don&rsquo;t force it to accept an ArrayList. The existence of an array in that case is and should remain an implementation detail.</p><p>Once again I agree, but there is nothing particularly profound to be learned here that <a href=https://en.wikipedia.org/wiki/Loose_coupling>loose coupling</a> doesn&rsquo;t already express in a more concise, coherent way.</p><hr><p>There we have it. Four inoffensive but uninspiring ideas sitting alongside one outright terrible one, as though they have equal merit.</p><p>I don’t believe you should trash something unless you’re able to propose a better alternative. Here are what I believe to be the essential concepts when it comes to object-oriented design:</p><ul><li>Encapsulation</li><li>Contemplate the right abstractions</li><li>Immutability</li><li>Avoid null references</li><li>Shorts methods and classes</li></ul><p>Of course there are probably hundreds more metrics by which you could judge whether some software is well-written - meaningful identifiers, tests, etc. - but those are applicable to other paradigms too.</p><p>Now all I need to do is reword them into a nice acrostic and I’ll be a millionaire too.</p><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>I couldn&rsquo;t find any direct source for this but this attribution is all over the internet, rightly or wrongly <a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></div></div></div></body></html>